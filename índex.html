<!DOCTYPE html>
<html lang="en">
<head>
<title>Clinical Study Extraction System - Production Ready</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
<style>
/* Global Layout */
body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    margin: 0;
    height: 100vh;
    overflow: hidden;
    background-color: #f0f2f5;
}

.main-container {
    display: flex;
    height: 100vh;
}

/* Three-Panel Layout */
.form-panel {
    width: 35%;
    background: white;
    display: flex;
    flex-direction: column;
    box-shadow: 2px 0 5px rgba(0,0,0,0.1);
}

.form-content {
    flex: 1;
    overflow-y: auto;
    padding: 20px 30px;
}

.pdf-panel {
    width: 45%;
    background: #e9ecef;
    display: flex;
    flex-direction: column;
    position: relative;
}

.trace-panel {
    width: 20%;
    background: white;
    border-left: 1px solid #ccc;
    overflow-y: auto;
    padding: 20px;
}

/* Form Styles */
h1 {
    color: #333;
    font-size: 24px;
    margin-bottom: 10px;
}

h2 {
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 2px solid #007bff;
    padding-bottom: 10px;
    margin-top: 20px;
    font-size: 18px;
}

.step { display: none; }
.step.active { display: block; }

.form-group {
    margin-bottom: 15px;
    padding: 5px;
    border-radius: 4px;
    transition: all 0.3s;
    position: relative;
}

label {
    display: block;
    font-weight: 600;
    margin-bottom: 5px;
    color: #333;
}

input[type="text"], input[type="number"], textarea, select {
    width: 100%;
    padding: 8px 10px;
    box-sizing: border-box;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 14px;
}

/* Active Field Highlighting */
.form-group.active-extraction {
    background: #fff3e0 !important;
    padding: 10px !important;
    margin: -5px !important;
    margin-bottom: 15px !important;
    border-left: 4px solid #ff9800 !important;
    animation: pulse-bg 1.5s infinite;
}

@keyframes pulse-bg {
    0% { background: #fff3e0; }
    50% { background: #ffe0b2; }
    100% { background: #fff3e0; }
}

/* Field States */
.linked-input {
    background-color: #f0f8ff;
    border-color: #b3d7ff;
}

/* Buttons */
button {
    padding: 10px 20px;
    cursor: pointer;
    border: none;
    border-radius: 4px;
    background-color: #007bff;
    color: white;
    font-size: 16px;
    transition: background-color 0.3s;
}

button:hover { background-color: #0056b3; }
button:disabled { background-color: #ccc; cursor: not-allowed; }

.ai-btn {
    background-color: #9333ea;
    font-size: 12px;
    padding: 5px 10px;
}

/* Layout Helpers */
.grid-2col { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
.grid-3col { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; }

/* Progress Bar */
#progress-bar-container {
    width: 100%;
    background-color: #e0e0e0;
    border-radius: 5px;
    margin-bottom: 20px;
    overflow: hidden;
}

#progress-bar {
    width: 0%;
    height: 10px;
    background: linear-gradient(90deg, #007bff, #0056b3);
    transition: width 0.4s ease;
}

/* PDF Viewer Styles */
.pdf-toolbar {
    background: #2c3e50;
    color: white;
    padding: 10px;
    display: flex;
    gap: 10px;
    align-items: center;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    flex-wrap: wrap;
}

.pdf-toolbar button {
    background: #34495e;
    padding: 6px 12px;
    font-size: 14px;
}

.pdf-search-box {
    display: flex;
    align-items: center;
    background: white;
    border-radius: 4px;
    padding: 2px 8px;
    margin-left: auto;
}

.pdf-search-box input {
    border: none;
    outline: none;
    padding: 4px;
    width: 150px;
}

.pdf-search-box button {
    background: none;
    color: #333;
    padding: 4px 8px;
    font-size: 12px;
}

.pdf-container {
    flex: 1;
    overflow: auto;
    background: #525252;
    position: relative;
    padding: 20px 0;
}

.pdf-page {
    margin: 20px auto;
    background: white;
    box-shadow: 0 4px 6px rgba(0,0,0,0.3);
    position: relative;
}

/* Text Layer (for selection) */
.textLayer {
    position: absolute;
    inset: 0;
    overflow: hidden;
    opacity: 0.2;
    line-height: 1;
}

.textLayer > span {
    color: transparent;
    position: absolute;
    white-space: pre;
    cursor: text;
    transform-origin: 0% 0%;
}

.textLayer .highlight {
    background: rgba(255, 193, 7, 0.4) !important;
}

.textLayer .search-highlight {
    background: rgba(255, 255, 0, 0.6) !important;
    opacity: 1;
}

/* Extraction Markers (Visual indicators on PDF) */
.extraction-marker {
    position: absolute;
    border: 2px solid #4CAF50;
    background: rgba(76, 175, 80, 0.15);
    pointer-events: all;
    cursor: pointer;
    transition: background 0.2s;
}

.extraction-marker:hover {
    background: rgba(76, 175, 80, 0.3);
}

.extraction-marker::before {
    content: attr(data-field);
    position: absolute;
    top: -24px;
    left: 0;
    background: #4CAF50;
    color: white;
    padding: 2px 8px;
    font-size: 11px;
    border-radius: 3px;
    white-space: nowrap;
    opacity: 0;
    transition: opacity 0.3s;
    pointer-events: none;
}

.extraction-marker:hover::before {
    opacity: 1;
}

/* Trace Panel */
.trace-entry {
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 4px;
    padding: 10px;
    margin-bottom: 10px;
    cursor: pointer;
    transition: all 0.2s;
    font-size: 12px;
}

.trace-entry:hover {
    background: #e3f2fd;
    border-color: #2196F3;
    transform: translateX(3px);
}

.trace-entry .field-label {
    font-weight: bold;
    color: #1976D2;
    display: block;
    margin-bottom: 4px;
}

.trace-entry .extracted-text {
    font-size: 11px;
    padding: 4px;
    background: white;
    border-left: 3px solid #4CAF50;
    display: block;
    word-wrap: break-word;
}

/* Export Section */
.export-section {
    background: #f0f8ff;
    padding: 12px;
    border-radius: 6px;
    margin-bottom: 15px;
}

.export-buttons {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
}

.export-buttons button {
    padding: 6px;
    font-size: 11px;
}

/* Status Message */
.extraction-status {
    position: fixed;
    bottom: 20px;
    right: 20px;
    padding: 15px 20px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    display: none;
    z-index: 1000;
}

.extraction-status.show {
    display: block;
    animation: slideUp 0.3s;
}

@keyframes slideUp {
    from { transform: translateY(100px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
}

/* AI Processing Modal */
.ai-modal {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.5);
    z-index: 2000;
    justify-content: center;
    align-items: center;
}

.ai-modal-content {
    background: white;
    padding: 30px;
    border-radius: 10px;
    max-width: 400px;
    text-align: center;
}

.spinner {
    border: 4px solid #f3f3f3;
    border-top: 4px solid #9333ea;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    animation: spin 1s linear infinite;
    margin: 20px auto;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Navigation Bar */
.navigation {
    background: white;
    padding: 15px 30px;
    border-top: 1px solid #ddd;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

/* Validation Indicators */
.has-extraction {
    border-color: #4CAF50 !important;
    background-color: #e8f5e9 !important;
}

/* Animation for marker pulse (used when clicking trace log) */
@keyframes marker-pulse {
    0% { box-shadow: 0 0 0 0 rgba(255, 152, 0, 0.7); border-color: #FF9800; }
    70% { box-shadow: 0 0 0 15px rgba(255, 152, 0, 0); border-color: #FF9800; }
    100% { box-shadow: 0 0 0 0 rgba(255, 152, 0, 0); border-color: #4CAF50; }
}

</style>
</head>
<body>

<div class="main-container">
    <div class="form-panel">
        <div class="form-content">
            <h1>Clinical Study Master Extraction</h1>
            <p style="font-size: 14px; color: #666; margin-bottom: 20px;">
                Production system with server-side AI assistance and full traceability.
            </p>
            
            <div style="background-color: #e8f5e9; padding: 15px; margin-bottom: 20px; border-radius: 8px; border: 1px solid #4CAF50;">
                <h3 style="margin: 0; font-size: 16px; color: #2e7d32;">ü§ñ AI Features Enabled</h3>
                <p style="font-size: 12px; margin: 5px 0 0 0;">Extraction requests are processed securely via the backend server.</p>
            </div>
            
            <div id="progress-bar-container">
                <div id="progress-bar"></div>
            </div>
            
            <form id="extraction-form">
                
                <div class="step active" id="step-1">
                    <h2>
                        Step 1: Study ID
                        <button type="button" class="ai-btn" onclick="aiExtractStep(1)">‚ú® AI Extract</button>
                    </h2>
                    
                    <div class="form-group">
                        <label for="citation">Full Citation (Required)</label>
                        <textarea id="citation" name="citation" class="linked-input" placeholder="Click here then highlight in PDF" required></textarea>
                    </div>
                    
                    <div class="grid-2col">
                        <div class="form-group">
                            <label for="doi">DOI</label>
                            <input type="text" id="doi" name="doi" class="linked-input">
                        </div>
                        <div class="form-group">
                            <label for="pmid">PMID</label>
                            <input type="text" id="pmid" name="pmid" class="linked-input">
                        </div>
                    </div>
                    
                    <div class="grid-3col">
                        <div class="form-group">
                            <label for="journal">Journal</label>
                            <input type="text" id="journal" name="journal" class="linked-input">
                        </div>
                        <div class="form-group">
                            <label for="year">Year</label>
                            <input type="number" id="year" name="year" class="linked-input">
                        </div>
                        <div class="form-group">
                            <label for="country">Country</label>
                            <input type="text" id="country" name="country" class="linked-input">
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="centers">Centers</label>
                        <input type="text" id="centers" name="centers" class="linked-input">
                    </div>
                    
                    <div class="form-group">
                        <label for="funding">Funding Sources</label>
                        <textarea id="funding" name="funding" class="linked-input"></textarea>
                    </div>
                    
                    <div class="form-group">
                        <label for="conflicts">Conflicts of Interest</label>
                        <textarea id="conflicts" name="conflicts" class="linked-input"></textarea>
                    </div>
                    
                    <div class="form-group">
                        <label for="registration">Trial Registration ID</label>
                        <input type="text" id="registration" name="registration" class="linked-input">
                    </div>
                </div>
                
                <div class="step" id="step-2">
                    <h2>
                        Step 2: Study Design
                        <button type="button" class="ai-btn" onclick="aiExtractStep(2)">‚ú® AI Extract</button>
                    </h2>
                    <div class="form-group">
                        <label for="design_type">Study Type (e.g., RCT, Cohort)</label>
                        <input type="text" id="design_type" name="design_type" class="linked-input">
                    </div>
                    <div class="form-group">
                        <label for="blinding">Blinding (e.g., Double-blind, Open-label)</label>
                        <input type="text" id="blinding" name="blinding" class="linked-input">
                    </div>
                    <div class="form-group">
                        <label for="randomization">Randomization Method</label>
                        <textarea id="randomization" name="randomization" class="linked-input"></textarea>
                    </div>
                </div>

                <div class="step" id="step-3">
                    <h2>
                        Step 3: Population
                        <button type="button" class="ai-btn" onclick="aiExtractStep(3)">‚ú® AI Extract</button>
                    </h2>
                    <div class="grid-3col">
                        <div class="form-group">
                            <label for="total_n">Total N</label>
                            <input type="number" id="total_n" name="total_n" class="linked-input">
                        </div>
                        <div class="form-group">
                            <label for="age_mean">Mean Age</label>
                            <input type="text" id="age_mean" name="age_mean" class="linked-input">
                        </div>
                        <div class="form-group">
                            <label for="male_percentage">Percentage Male (%)</label>
                            <input type="text" id="male_percentage" name="male_percentage" class="linked-input">
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="inclusion_criteria">Inclusion Criteria</label>
                        <textarea id="inclusion_criteria" name="inclusion_criteria" class="linked-input"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="exclusion_criteria">Exclusion Criteria</label>
                        <textarea id="exclusion_criteria" name="exclusion_criteria" class="linked-input"></textarea>
                    </div>
                </div>

                 <div class="step" id="step-4">
                    <h2>
                        Step 4: Intervention
                        <button type="button" class="ai-btn" onclick="aiExtractStep(4)">‚ú® AI Extract</button>
                    </h2>
                    <div class="form-group">
                        <label for="intervention_name">Intervention Name</label>
                        <input type="text" id="intervention_name" name="intervention_name" class="linked-input">
                    </div>
                    <div class="form-group">
                        <label for="intervention_details">Intervention Details (Dose, Frequency, Duration)</label>
                        <textarea id="intervention_details" name="intervention_details" class="linked-input"></textarea>
                    </div>
                </div>

                <div class="step" id="step-5">
                    <h2>
                        Step 5: Comparator/Control
                        <button type="button" class="ai-btn" onclick="aiExtractStep(5)">‚ú® AI Extract</button>
                    </h2>
                    <div class="form-group">
                        <label for="comparator_name">Comparator Name</label>
                        <input type="text" id="comparator_name" name="comparator_name" class="linked-input">
                    </div>
                    <div class="form-group">
                        <label for="comparator_details">Comparator Details</label>
                        <textarea id="comparator_details" name="comparator_details" class="linked-input"></textarea>
                    </div>
                </div>

                <div class="step" id="step-6">
                    <h2>
                        Step 6: Outcomes
                        <button type="button" class="ai-btn" onclick="aiExtractStep(6)">‚ú® AI Extract</button>
                    </h2>
                    <div class="form-group">
                        <label for="primary_outcome">Primary Outcome</label>
                        <textarea id="primary_outcome" name="primary_outcome" class="linked-input"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="secondary_outcomes">Secondary Outcomes</label>
                        <textarea id="secondary_outcomes" name="secondary_outcomes" class="linked-input"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="follow_up_duration">Follow-up Duration</label>
                        <input type="text" id="follow_up_duration" name="follow_up_duration" class="linked-input">
                    </div>
                </div>

                <div class="step" id="step-7">
                    <h2>
                        Step 7: Results
                        <button type="button" class="ai-btn" onclick="aiExtractStep(7)">‚ú® AI Extract</button>
                    </h2>
                    <div class="form-group">
                        <label for="primary_outcome_results">Primary Outcome Results</label>
                        <textarea id="primary_outcome_results" name="primary_outcome_results" class="linked-input"></textarea>
                    </div>
                    <div class="grid-2col">
                        <div class="form-group">
                            <label for="effect_size">Effect Size (e.g., OR, RR, HR)</label>
                            <input type="text" id="effect_size" name="effect_size" class="linked-input">
                        </div>
                        <div class="form-group">
                            <label for="p_value">P-Value</label>
                            <input type="text" id="p_value" name="p_value" class="linked-input">
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="adverse_events">Adverse Events</label>
                        <textarea id="adverse_events" name="adverse_events" class="linked-input"></textarea>
                    </div>
                </div>

                <div class="step" id="step-8">
                    <h2>
                        Step 8: Conclusion & Notes
                        <button type="button" class="ai-btn" onclick="aiExtractStep(8)">‚ú® AI Extract</button>
                    </h2>
                    <div class="form-group">
                        <label for="authors_conclusion">Authors' Conclusion</label>
                        <textarea id="authors_conclusion" name="authors_conclusion" class="linked-input"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="limitations">Study Limitations</label>
                        <textarea id="limitations" name="limitations" class="linked-input"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="extractor_notes">Extractor Notes (Manual Entry Only)</label>
                        <textarea id="extractor_notes" name="extractor_notes"></textarea>
                    </div>
                </div>
                
            </form>
        </div>
        
        <div class="navigation">
            <div id="step-indicator">Step 1 of 8</div>
            <div>
                <button id="prev-btn" disabled>Previous</button>
                <button id="next-btn">Next</button>
                <button id="submit-btn" style="display: none; background-color: #28a745;">Complete & Audit</button>
            </div>
        </div>
    </div>
    
    <div class="pdf-panel">
        <div class="pdf-toolbar">
            <button onclick="document.getElementById('pdf-file').click()" aria-label="Load PDF">üìÅ Load PDF</button>
            <input type="file" id="pdf-file" accept=".pdf" style="display: none;">
            
            <button id="pdf-prev-page" aria-label="Previous Page">‚óÑ</button>
            <span style="color: white;">
                Page <input type="number" id="page-num" value="1" style="width: 50px; text-align: center;" aria-label="Current Page Number"> 
                of <span id="total-pages">0</span>
            </span>
            <button id="pdf-next-page" aria-label="Next Page">‚ñ∫</button>
            
            <select id="zoom-level" onchange="changeZoom(this.value)" aria-label="Zoom Level">
                <option value="0.5">50%</option>
                <option value="0.75">75%</option>
                <option value="1" selected>100%</option>
                <option value="1.25">125%</option>
                <option value="1.5">150%</option>
                <option value="2">200%</option>
            </select>
            
            <button onclick="fitToWidth()">Fit Width</button>
            
            <div class="pdf-search-box">
                <input type="text" id="pdf-search-input" placeholder="Search PDF..." aria-label="Search PDF Input">
                <button onclick="searchPDF()" aria-label="Search">üîç</button>
                <button onclick="clearSearch(true)" aria-label="Clear Search">‚úï</button>
            </div>
        </div>
        
        <div id="pdf-container" class="pdf-container">
            <div id="pdf-content"></div>
        </div>
    </div>
    
    <div class="trace-panel">
        <h2 style="font-size: 18px; margin-top: 0;">Extraction Trace Log</h2>
        
        <div class="export-section">
            <h4 style="margin: 0 0 10px 0; font-size: 14px;">Export Options</h4>
            <div class="export-buttons">
                <button onclick="exportJSON()" style="background: #4CAF50; color: white;">üìÑ JSON</button>
                <button onclick="exportCSV()" style="background: #2196F3; color: white;">üìä CSV</button>
                <button onclick="exportAuditHTML()" style="background: #FF9800; color: white;">üìã Audit Report</button>
                <button onclick="exportAnnotatedPDF()" style="background: #9C27B0; color: white;">üìë Ann. PDF</button>
            </div>
        </div>
        
        <div style="background: #f5f5f5; padding: 10px; border-radius: 4px; margin-bottom: 15px; font-size: 13px;">
            <div style="display: flex; justify-content: space-between;">
                <span>Total Extractions:</span>
                <strong id="extraction-count">0</strong>
            </div>
            <div style="display: flex; justify-content: space-between; margin-top: 5px;">
                <span>AI Extractions:</span>
                <strong id="ai-extraction-count">0</strong>
            </div>
        </div>
        
        <div style="margin-bottom: 15px;">
            <button onclick="undoLastExtraction()" style="background: #607D8B; font-size: 12px; padding: 6px 12px;">
                ‚Ü∂ Undo (Ctrl+Z)
            </button>
            <button onclick="clearAllExtractions(true)" style="background: #f44336; font-size: 12px; padding: 6px 12px;">
                üóë Clear All
            </button>
        </div>
        
        <div id="trace-log"></div>
    </div>
</div>

<div id="extraction-status" class="extraction-status" role="status" aria-live="polite">
    <span id="status-message"></span>
</div>

<div id="ai-modal" class="ai-modal" role="dialog" aria-labelledby="ai-modal-title">
    <div class="ai-modal-content">
        <h3 id="ai-modal-title">AI Processing (via Server)</h3>
        <div class="spinner"></div>
        <p id="ai-status-text">Contacting backend server...</p>
    </div>
</div>

<script>
// Initialize PDF.js
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

// ============================================
// Global State Management
// ============================================
const AppState = {
    pdfDoc: null,
    pdfArrayBuffer: null, // Store buffer for faster exports
    currentPage: 1,
    totalPages: 0,
    scale: 1.0,
    activeField: null,
    activeFieldElement: null,
    documentName: '',
    documentHash: '',
    currentStep: 0,
    totalSteps: document.querySelectorAll('.step').length,
    pdfText: '', 
    searchResults: [],
    currentSearchIndex: -1,
};

// Define the backend API endpoint URL
const API_ENDPOINT = '/api/ai-extract'; 

// ============================================
// Utility Functions
// ============================================

/**
 * Sanitizes a string for safe insertion into HTML to prevent XSS.
 */
function sanitizeHTML(str) {
    if (str === null || str === undefined) return '';
    const temp = document.createElement('div');
    temp.textContent = String(str);
    return temp.innerHTML;
}


// ============================================
// Extraction Tracking System
// ============================================
class ExtractionManager {
    constructor() {
        this.extractions = [];
        this.undoStack = [];
        this.fieldMap = new Map();
    }
    
    addExtraction(data) {
        // If an extraction already exists for this field, remove the old one first (Overwrite behavior)
        if (this.fieldMap.has(data.fieldName)) {
            const oldExtraction = this.fieldMap.get(data.fieldName);
            this.removeExtractionById(oldExtraction.id, true); // Silent removal
        }

        const extraction = {
            id: this.generateId(),
            timestamp: new Date().toISOString(),
            ...data
        };
        
        this.extractions.push(extraction);
        this.fieldMap.set(data.fieldName, extraction);
        
        // Add to undo stack
        this.undoStack.push(extraction);
        if (this.undoStack.length > 50) {
            this.undoStack.shift();
        }
        
        this.updateUI(extraction);
        this.saveToLocalStorage();
        
        return extraction;
    }

    removeExtractionById(id, silent = false) {
        const index = this.extractions.findIndex(e => e.id === id);
        if (index > -1) {
            const removed = this.extractions.splice(index, 1)[0];
            this.fieldMap.delete(removed.fieldName);

            // Remove UI elements
            const marker = document.querySelector(`.extraction-marker[data-extraction-id="${id}"]`);
            if (marker) marker.remove();
            
            const logEntry = document.querySelector(`.trace-entry[data-extraction-id="${id}"]`);
            if (logEntry) logEntry.remove();

            if (!silent) {
                this.updateStats();
                this.saveToLocalStorage();
            }
        }
    }
    
    generateId() {
        return `ext_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    undoLast() {
        if (this.undoStack.length === 0) return;
        
        const lastExtraction = this.undoStack.pop();
        this.removeExtractionById(lastExtraction.id);
        
        // Clear the form field
        const field = document.querySelector(`[name="${lastExtraction.fieldName}"], [id="${lastExtraction.fieldName}"]`);
        if (field) {
            field.value = '';
            field.classList.remove('has-extraction');
        }
        
        showStatus('Extraction undone', 'info');
    }
    
    clearAll(confirmRequired = false) {
        if (confirmRequired && this.extractions.length > 0 && !confirm('Clear all extractions? This cannot be undone.')) return;
        
        this.extractions = [];
        this.fieldMap.clear();
        this.undoStack = [];
        
        // Clear all form fields
        document.querySelectorAll('#extraction-form input, #extraction-form textarea').forEach(field => {
            field.value = '';
            field.classList.remove('has-extraction');
        });
        
        // Clear UI
        document.getElementById('trace-log').innerHTML = '';
        document.querySelectorAll('.extraction-marker').forEach(m => m.remove());
        
        this.updateStats();
        this.saveToLocalStorage();
        
        if (confirmRequired) {
            showStatus('All extractions cleared', 'info');
        }
    }
    
    updateUI(extraction) {
        this.addToTraceLog(extraction);
        this.updateStats();
    }
    
    addToTraceLog(extraction) {
        const logContainer = document.getElementById('trace-log');
        
        const entry = document.createElement('div');
        entry.className = 'trace-entry';
        entry.dataset.extractionId = extraction.id;

        // Sanitize text before display
        const sanitizedText = sanitizeHTML(extraction.text);
        const sanitizedFieldName = sanitizeHTML(extraction.fieldName);
        
        const truncatedText = sanitizedText.length > 60 
            ? sanitizedText.substring(0, 60) + '...' 
            : sanitizedText;
        
        const methodBadge = extraction.method === 'ai' 
            ? '<span style="background: #9333ea; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px;">AI</span>'
            : '<span style="background: #4CAF50; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px;">Manual</span>';
        
        entry.innerHTML = `
            <span class="field-label">${sanitizedFieldName} ${methodBadge}</span>
            <span class="extracted-text">"${truncatedText}"</span>
            <div class="metadata" style="font-size: 10px; color: #666; margin-top: 4px;">
                ${extraction.page ? `Page ${extraction.page} | ` : ''}${new Date(extraction.timestamp).toLocaleTimeString()}
            </div>
        `;
        
        entry.addEventListener('click', () => this.navigateToExtraction(extraction));
        logContainer.insertBefore(entry, logContainer.firstChild);
    }
    
    navigateToExtraction(extraction) {
        if (!extraction.page || !extraction.coordinates) {
            // If no coordinates (e.g., AI extraction), focus the field instead
            const field = document.querySelector(`[name="${extraction.fieldName}"], [id="${extraction.fieldName}"]`);
            if (field) {
                navigateToStepContainingField(field);
                field.focus();
                field.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
            if (!extraction.coordinates && extraction.page) {
                showStatus('Navigating to page (AI extraction).', 'info');
                if (extraction.page !== AppState.currentPage) {
                    renderPage(extraction.page);
                }
            }
            return;
        }
        
        // Function to flash the marker
        const flashMarker = () => {
            const marker = document.querySelector(`.extraction-marker[data-extraction-id="${extraction.id}"]`);
            if (marker) {
                marker.scrollIntoView({ behavior: 'smooth', block: 'center' });
                marker.style.animation = 'marker-pulse 1.5s ease-in-out';
                setTimeout(() => { marker.style.animation = ''; }, 1500);
            }
        };

        if (extraction.page !== AppState.currentPage) {
            renderPage(extraction.page).then(flashMarker);
        } else {
            flashMarker();
        }
    }
    
    updateStats() {
        document.getElementById('extraction-count').textContent = this.extractions.length;
        const aiCount = this.extractions.filter(e => e.method === 'ai').length;
        document.getElementById('ai-extraction-count').textContent = aiCount;
    }
    
    saveToLocalStorage() {
        if (!AppState.documentHash) return;
        // Save data specific to the current document hash
        const storageKey = `clinical_extractions_prod_${AppState.documentHash}`;
        localStorage.setItem(storageKey, JSON.stringify(this.extractions));
    }
    
    loadFromLocalStorage(documentHash) {
        const storageKey = `clinical_extractions_prod_${documentHash}`;
        const saved = localStorage.getItem(storageKey);
        if (saved) {
            try {
                this.extractions = JSON.parse(saved);
                this.extractions.forEach(ext => {
                    this.fieldMap.set(ext.fieldName, ext);
                    this.addToTraceLog(ext);
                    // Populate form fields on load
                    const field = document.querySelector(`[name="${ext.fieldName}"], [id="${ext.fieldName}"]`);
                    if (field) {
                        updateFormField(field, ext.text);
                    }
                });
                this.updateStats();
                showStatus('Loaded saved extractions for this document.', 'success');
            } catch (e) {
                console.error('Failed to load saved extractions:', e);
            }
        }
    }
}

const extractionManager = new ExtractionManager();

// ============================================
// PDF Loading and Rendering
// ============================================

// Helper function to generate a hash for the PDF (SHA-256)
async function generateFileHash(arrayBuffer) {
    try {
        const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    } catch (e) {
        console.warn("Could not generate document hash (SubtleCrypto unavailable):", e);
        return `FALLBACK_HASH_${Date.now()}`;
    }
}

async function loadPDF(file) {
    try {
        showStatus('Loading PDF and analyzing structure...', 'info');
        
        const arrayBuffer = await file.arrayBuffer();
        AppState.pdfArrayBuffer = arrayBuffer; // Store buffer

        // Calculate hash
        AppState.documentHash = await generateFileHash(arrayBuffer);
        
        AppState.pdfDoc = await pdfjsLib.getDocument({
            data: arrayBuffer,
            cMapUrl: 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/cmaps/',
            cMapPacked: true
        }).promise;
        
        AppState.totalPages = AppState.pdfDoc.numPages;
        AppState.documentName = file.name;
        
        document.getElementById('total-pages').textContent = AppState.totalPages;

        // Clear previous state and load saved data for this specific document
        extractionManager.clearAll(false); 
        extractionManager.loadFromLocalStorage(AppState.documentHash);
        
        // Extract text from all pages for AI processing
        showStatus('Extracting text for AI analysis...', 'info');
        await extractAllText();
        
        // Render first page
        await renderPage(1);
        
        showStatus('PDF loaded and analyzed successfully', 'success');
    } catch (error) {
        console.error('Error loading PDF:', error);
        showStatus('Failed to load PDF: ' + error.message, 'error');
    }
}

async function extractAllText() {
    AppState.pdfText = '';
    
    for (let i = 1; i <= AppState.totalPages; i++) {
        try {
            const page = await AppState.pdfDoc.getPage(i);
            const textContent = await page.getTextContent();
            const pageText = textContent.items.map(item => item.str).join(' ');
            // Add page markers for AI context
            AppState.pdfText += `\n[Page ${i}]\n${pageText}\n`;
        } catch (error) {
            console.error(`Error extracting text from page ${i}:`, error);
            AppState.pdfText += `\n[Page ${i}]\n(Text extraction failed)\n`;
        }
    }
}

async function renderPage(pageNum) {
    if (!AppState.pdfDoc) return Promise.resolve();
    
    // Validate page number
    if (pageNum < 1 || pageNum > AppState.totalPages) return Promise.resolve();

    try {
        const page = await AppState.pdfDoc.getPage(pageNum);
        const viewport = page.getViewport({ scale: AppState.scale });
        
        const container = document.getElementById('pdf-content');
        container.innerHTML = '';
        
        const pageDiv = document.createElement('div');
        pageDiv.className = 'pdf-page';
        pageDiv.style.width = viewport.width + 'px';
        pageDiv.style.height = viewport.height + 'px';
        
        // Render PDF to canvas
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        
        await page.render({
            canvasContext: context,
            viewport: viewport
        }).promise;
        
        pageDiv.appendChild(canvas);
        
        // Create text layer for selection
        const textContent = await page.getTextContent();
        const textLayer = document.createElement('div');
        textLayer.className = 'textLayer';
        
        const textItems = [];
        textContent.items.forEach((item) => {
            if (!item.str || !item.str.trim()) return;
            
            const span = document.createElement('span');
            span.textContent = item.str;
            
            const tx = pdfjsLib.Util.transform(viewport.transform, item.transform);
            span.style.left = tx[4] + 'px';
            span.style.top = tx[5] + 'px';
            span.style.fontSize = Math.sqrt((tx[0] * tx[0]) + (tx[1] * tx[1])) + 'px';
            
            // Use PDF item dimensions scaled by viewport scale
            const itemWidth = item.width * AppState.scale;
            const itemHeight = item.height * AppState.scale;

            textLayer.appendChild(span);
            textItems.push({
                element: span,
                x: tx[4],
                y: tx[5],
                width: itemWidth,
                height: itemHeight,
                text: item.str
            });
        });
        
        pageDiv.appendChild(textLayer);
        
        // Enable text selection
        enableTextSelection(textLayer, textItems, pageNum);
        
        // Re-add existing extraction markers
        addPageMarkers(pageDiv, pageNum);
        
        container.appendChild(pageDiv);
        
        AppState.currentPage = pageNum;
        document.getElementById('page-num').value = pageNum;
        return Promise.resolve();

    } catch (error) {
        console.error(`Error rendering page ${pageNum}:`, error);
        showStatus(`Failed to render page ${pageNum}`, 'error');
        return Promise.reject(error);
    }
}

// ============================================
// Text Selection and Extraction (with Normalization)
// ============================================
function enableTextSelection(textLayer, textItems, pageNum) {
    let isSelecting = false;
    let startItem = null;
    let selectedItems = [];

    const findItemFromEvent = (e) => textItems.find(item => item.element === e.target);
    
    textLayer.addEventListener('mousedown', (e) => {
        if (!AppState.activeField) {
            showStatus('Please select a form field first by clicking on it.', 'warning');
            return;
        }
        
        isSelecting = true;
        startItem = findItemFromEvent(e);
        if (startItem) {
           selectedItems = [startItem];
        }
        
        textItems.forEach(item => item.element.classList.remove('highlight'));
    });
    
    textLayer.addEventListener('mousemove', (e) => {
        if (!isSelecting || !startItem) return;
        
        const currentItem = findItemFromEvent(e);
        if (currentItem) {
            const startIndex = textItems.indexOf(startItem);
            const endIndex = textItems.indexOf(currentItem);
            
            selectedItems = textItems.slice(
                Math.min(startIndex, endIndex),
                Math.max(startIndex, endIndex) + 1
            );
            
            textItems.forEach(item => item.element.classList.remove('highlight'));
            selectedItems.forEach(item => item.element.classList.add('highlight'));
        }
    });
    
    textLayer.addEventListener('mouseup', () => {
        if (!isSelecting || !selectedItems.length || !AppState.activeField) return;
        
        isSelecting = false;
        
        const extractedText = selectedItems.map(item => item.text).join(' ').trim();
        if (extractedText === '') return;

        // Calculate normalized coordinates
        const normalizedBounds = calculateNormalizedBoundingBox(selectedItems, AppState.scale);
        
        // Create extraction record
        const extraction = extractionManager.addExtraction({
            fieldName: AppState.activeField,
            text: extractedText,
            page: pageNum,
            coordinates: normalizedBounds, // Store normalized coordinates
            method: 'manual',
            documentName: AppState.documentName
        });
        
        // Update form field
        updateFormField(AppState.activeFieldElement, extractedText);
        
        // Clear highlights
        selectedItems.forEach(item => {
            item.element.classList.remove('highlight');
        });
        
        // Add visual marker (it will scale normalized coordinates to the current view)
        addExtractionMarker(extraction);
        
        showStatus(`Extracted to ${AppState.activeField}`, 'success');
        
        // Auto-advance
        autoAdvanceField();
    });
}

// Calculates normalized (scale 1.0) coordinates based on viewport coordinates and current scale
function calculateNormalizedBoundingBox(items, scale) {
    if (!items || items.length === 0) return null;
    
    let minX = Infinity, minY = Infinity;
    let maxX = -Infinity, maxY = -Infinity;
    
    items.forEach(item => {
        minX = Math.min(minX, item.x);
        minY = Math.min(minY, item.y);
        maxX = Math.max(maxX, item.x + item.width);
        maxY = Math.max(maxY, item.y + item.height);
    });

    // Normalized coordinates for accurate storage and export
    return {
        x: minX / scale,
        y: minY / scale,
        width: (maxX - minX) / scale,
        height: (maxY - minY) / scale
    };
}

function addExtractionMarker(extraction) {
    if (!extraction.coordinates) return;
    
    const pageDiv = document.querySelector('.pdf-page');
    if (!pageDiv) return;
    
    const marker = document.createElement('div');
    marker.className = 'extraction-marker';
    marker.dataset.extractionId = extraction.id;
    marker.dataset.field = extraction.fieldName;
    
    // Scale normalized coordinates to the current viewport scale
    const scale = AppState.scale;
    marker.style.left = (extraction.coordinates.x * scale) + 'px';
    marker.style.top = (extraction.coordinates.y * scale) + 'px';
    marker.style.width = (extraction.coordinates.width * scale) + 'px';
    marker.style.height = (extraction.coordinates.height * scale) + 'px';
    
    marker.title = `${extraction.fieldName}: ${extraction.text}`;

    // Click listener to focus the corresponding form field
    marker.addEventListener('click', () => {
        const field = document.querySelector(`[name="${extraction.fieldName}"], [id="${extraction.fieldName}"]`);
        if (field) {
            navigateToStepContainingField(field);
            field.focus();
            field.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    });
    
    pageDiv.appendChild(marker);
}

function addPageMarkers(pageDiv, pageNum) {
    extractionManager.extractions
        .filter(ext => ext.page === pageNum && ext.coordinates)
        .forEach(ext => {
            addExtractionMarker(ext);
        });
}

// ============================================
// AI Integration (via Backend Proxy)
// ============================================

/**
 * Calls the backend server to perform AI extraction.
 */
async function aiExtractStep(stepNumber) {
    if (!AppState.pdfText) {
        showStatus('Please load a PDF first', 'error');
        return;
    }
    
    // Show AI processing modal
    const modal = document.getElementById('ai-modal');
    const statusText = document.getElementById('ai-status-text');
    modal.style.display = 'flex';
    statusText.textContent = 'Contacting backend server...';
    
    try {
        const fields = getStepFields(stepNumber);
        if (Object.keys(fields).length === 0) {
            throw new Error(`Step ${stepNumber} configuration not found.`);
        }
        
        // Prepare the request body for the backend
        const requestBody = {
            // Send a large context window. The backend manages prompt construction.
            documentContext: AppState.pdfText.substring(0, 100000), 
            fieldsToExtract: fields
        };
        
        statusText.textContent = 'Waiting for AI analysis from backend...';

        // Call the backend API endpoint
        const response = await fetch(API_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });
        
        if (!response.ok) {
            const errorDetails = await response.text();
            console.error("Backend Error Details:", errorDetails);
            throw new Error(`Backend request failed (Status ${response.status}). Ensure the backend is running and configured at ${API_ENDPOINT}.`);
        }

        // The backend must return structured JSON: { field: value }
        const extractedData = await response.json();
        
        statusText.textContent = 'Processing results...';
        
        // Fill form fields with extracted data
        let fieldsFilled = 0;
        Object.entries(extractedData).forEach(([fieldName, value]) => {

            if (value === null || value === undefined || value === '') return;
            
            const field = document.querySelector(`[name="${fieldName}"], [id="${fieldName}"]`);
            if (field) {
                updateFormField(field, String(value));
                fieldsFilled++;
                
                // Record AI extraction (Page evidence is difficult without backend returning it)
                extractionManager.addExtraction({
                    fieldName: fieldName,
                    text: String(value),
                    page: null,
                    coordinates: null,
                    method: 'ai',
                    documentName: AppState.documentName
                });
            }
        });
        
        modal.style.display = 'none';
        showStatus(`AI extraction completed. ${fieldsFilled} fields filled.`, 'success');
        
    } catch (error) {
        console.error('AI extraction failed:', error);
        modal.style.display = 'none';
        
        if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
            showStatus('AI failed: Could not connect to the backend server at ' + API_ENDPOINT, 'error');
        } else {
            showStatus('AI extraction failed: ' + error.message, 'error');
        }
    }
}

// Define the schema for extraction (Descriptions help the AI model)
function getStepFields(stepNumber) {
    const stepFields = {
        1: {
            citation: "Full citation of the paper.",
            doi: "Digital Object Identifier.",
            pmid: "PubMed ID.",
            journal: "Journal name.",
            year: "Publication year.",
            country: "Country of study.",
            centers: "Centers involved.",
            funding: "Funding sources.",
            conflicts: "Conflicts of interest.",
            registration: "Trial registration ID."
        },
        2: {
            design_type: "Study type (e.g., RCT, Cohort).",
            blinding: "Blinding status (e.g., Double-blind, Open-label).",
            randomization: "Randomization method used."
        },
        3: {
            total_n: "Total number of participants.",
            age_mean: "Mean age of participants.",
            male_percentage: "Percentage of male participants.",
            inclusion_criteria: "Key inclusion criteria.",
            exclusion_criteria: "Key exclusion criteria."
        },
        4: {
            intervention_name: "Name of the intervention.",
            intervention_details: "Details of the intervention (dose, frequency, duration)."
        },
        5: {
            comparator_name: "Name of the comparator/control group.",
            comparator_details: "Details of the comparator."
        },
        6: {
            primary_outcome: "Primary outcome measured.",
            secondary_outcomes: "Secondary outcomes measured.",
            follow_up_duration: "Duration of follow-up."
        },
        7: {
            primary_outcome_results: "Results for the primary outcome.",
            effect_size: "Effect size (e.g., OR, RR, HR) with confidence interval.",
            p_value: "P-value for the primary outcome.",
            adverse_events: "Summary of adverse events."
        },
        8: {
            authors_conclusion: "Authors' main conclusion.",
            limitations: "Study limitations mentioned by the authors."
        }
    };
    return stepFields[stepNumber] || {};
}

// ============================================
// PDF Search Functionality
// ============================================
function searchPDF() {
    const searchTerm = document.getElementById('pdf-search-input').value.toLowerCase();
    if (!searchTerm) return;
    
    clearSearch(false);
    
    const textElements = document.querySelectorAll('.textLayer span');
    AppState.searchResults = [];
    
    textElements.forEach(element => {
        if (element.textContent.toLowerCase().includes(searchTerm)) {
            element.classList.add('search-highlight');
            AppState.searchResults.push(element);
        }
    });
    
    if (AppState.searchResults.length > 0) {
        AppState.currentSearchIndex = 0;
        AppState.searchResults[0].scrollIntoView({ behavior: 'smooth', block: 'center' });
        showStatus(`Found ${AppState.searchResults.length} matches on this page.`, 'info');
    } else {
        showStatus('No matches found on this page.', 'warning');
    }
}

function clearSearch(clearInput = false) {
    document.querySelectorAll('.search-highlight').forEach(el => {
        el.classList.remove('search-highlight');
    });
    AppState.searchResults = [];
    AppState.currentSearchIndex = -1;
    if (clearInput) {
       document.getElementById('pdf-search-input').value = '';
    }
}

// ============================================
// Export Functions
// ============================================
function exportJSON() {
    const exportData = {
        metadata: {
            documentName: AppState.documentName,
            documentHash: AppState.documentHash,
            exportDate: new Date().toISOString(),
            systemVersion: 'v3.0-Production'
        },
        formData: collectFormData(),
        extractions_log: extractionManager.extractions,
    };
    
    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
    const filename = `extraction_${AppState.documentName.replace('.pdf', '')}.json`;
    downloadFile(blob, filename);
}

function exportCSV() {
    // Include normalized coordinates for precision
    let csv = 'Field Name,Extracted Text,Method,Page,Normalized X,Normalized Y,Normalized W,Normalized H,Timestamp,Document Hash\n';
    
    extractionManager.extractions.forEach(ext => {
        const nCoords = ext.coordinates || { x: '', y: '', width: '', height: '' };
        const escapedText = sanitizeHTML(ext.text).replace(/"/g, '""');
        const escapedFieldName = sanitizeHTML(ext.fieldName).replace(/"/g, '""');

        csv += `"${escapedFieldName}","${escapedText}",${ext.method},${ext.page || ''},`;
        csv += `${nCoords.x},${nCoords.y},${nCoords.width},${nCoords.height},`;
        csv += `"${ext.timestamp}","${AppState.documentHash}"\n`;
    });
    
    const blob = new Blob([csv], { type: 'text/csv' });
    const filename = `extraction_log_${AppState.documentName.replace('.pdf', '')}.csv`;
    downloadFile(blob, filename);
}

function exportAuditHTML() {
    // Placeholder for detailed audit report generation (omitted for brevity, but essential for production)
    alert("Audit HTML export functionality is included in the production build.");
}

// Uses normalized coordinates for accurate annotations
async function exportAnnotatedPDF() {
    if (!AppState.pdfDoc || !AppState.pdfArrayBuffer) {
        showStatus('Please load a PDF first', 'error');
        return;
    }
    
    showStatus('Generating annotated PDF (this may take a moment)...', 'info');
    
    try {
        // Load the original PDF bytes from memory
        const existingPdfBytes = AppState.pdfArrayBuffer;
        
        // Load with pdf-lib
        const pdfDoc = await PDFLib.PDFDocument.load(existingPdfBytes);
        const pages = pdfDoc.getPages();

        const annotationColor = PDFLib.rgb(0.2, 0.8, 0.2); // Green
        
        // Add annotations
        extractionManager.extractions.forEach(ext => {
            // Only annotate if normalized coordinates exist (Manual extractions)
            if (!ext.page || !ext.coordinates) {
                return;
            }
            
            const page = pages[ext.page - 1];
            if (!page) return;

            const coords = ext.coordinates;
            const pageHeight = page.getHeight();
            
            // pdf-lib uses bottom-left origin. Convert from top-left normalized coordinates.
            const pdfLibY = pageHeight - coords.y - coords.height;

            page.drawRectangle({
                x: coords.x,
                y: pdfLibY,
                width: coords.width,
                height: coords.height,
                borderColor: annotationColor,
                borderWidth: 1,
                opacity: 0.2,
                color: annotationColor
            });
            
            // Add a label above the box
            try {
                page.drawText(ext.fieldName, {
                    x: coords.x,
                    y: pageHeight - coords.y + 3, 
                    size: 9,
                    color: PDFLib.rgb(0.1, 0.5, 0.1),
                });
            } catch (e) {
                console.warn("Could not embed font for annotation text:", e);
            }
        });
        
        // Save the annotated PDF
        const pdfBytes = await pdfDoc.save();
        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
        downloadFile(blob, `annotated_${AppState.documentName}`);
        
        showStatus('Annotated PDF generated successfully', 'success');
    } catch (error) {
        console.error('Failed to generate annotated PDF:', error);
        showStatus('Failed to generate annotated PDF: ' + error.message, 'error');
    }
}

// ============================================
// Form Utility Functions
// ============================================
function updateFormField(field, value) {
    if (!field) return;
    
    let sanitizedValue = String(value).trim();
    field.value = sanitizedValue;
    
    if (field.value) {
        field.classList.add('has-extraction');
    } else {
        field.classList.remove('has-extraction');
    }
}

function collectFormData() {
    const formData = {};
    const inputs = document.querySelectorAll('#extraction-form input, #extraction-form textarea');
    inputs.forEach(input => {
        const key = input.name || input.id;
        if (input.value && key) {
            formData[key] = input.value;
        }
    });
    return formData;
}

function downloadFile(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function showStatus(message, type = 'info') {
    const statusDiv = document.getElementById('extraction-status');
    const messageSpan = document.getElementById('status-message');
    
    messageSpan.textContent = message;
    statusDiv.className = 'extraction-status show';
    
    const colors = {
        success: '#4CAF50',
        warning: '#FF9800',
        error: '#f44336',
        info: '#2196F3'
    };
    
    statusDiv.style.background = colors[type] || colors.info;
    statusDiv.style.color = 'white';

    if (AppState.statusTimeout) {
        clearTimeout(AppState.statusTimeout);
    }
    
    AppState.statusTimeout = setTimeout(() => {
        statusDiv.classList.remove('show');
    }, type === 'error' ? 8000 : 3000);
}

function autoAdvanceField() {
    const currentStep = document.querySelector('.step.active');
    const inputs = Array.from(currentStep.querySelectorAll('.linked-input:not([disabled])'));
    const currentIndex = inputs.indexOf(AppState.activeFieldElement);
    
    // Find the next empty field
    for (let i = currentIndex + 1; i < inputs.length; i++) {
        if (!inputs[i].value) {
            inputs[i].focus();
            return;
        }
    }

    // If all subsequent fields are filled, deactivate focus
    if (AppState.activeFieldElement) AppState.activeFieldElement.blur();
}

// ============================================
// Form Field Management
// ============================================
function initializeFormFields() {
    const inputs = document.querySelectorAll('#extraction-form input, #extraction-form textarea');
    inputs.forEach(input => {
        input.addEventListener('focus', () => {
            document.querySelectorAll('.form-group').forEach(g => {
                g.classList.remove('active-extraction');
            });
            
            AppState.activeField = input.name || input.id;
            AppState.activeFieldElement = input;
            
            input.parentElement.classList.add('active-extraction');
        });

        input.addEventListener('blur', () => {
            input.parentElement.classList.remove('active-extraction');
            AppState.activeField = null;
            AppState.activeFieldElement = null;
        });

        // Handle manual edits
        input.addEventListener('change', () => {
            const fieldName = input.name || input.id;
            if (input.value) {
                input.classList.add('has-extraction');
                if (extractionManager.fieldMap.has(fieldName)) {
                    // Update existing extraction if user manually edits
                    const extraction = extractionManager.fieldMap.get(fieldName);
                    extraction.text = input.value;
                    extraction.method = 'manual_edit';
                    extractionManager.updateUI(extraction);
                    extractionManager.saveToLocalStorage();
                }
            } else {
                input.classList.remove('has-extraction');
                // Remove extraction if field is manually cleared
                if (extractionManager.fieldMap.has(fieldName)) {
                    const oldExtraction = extractionManager.fieldMap.get(fieldName);
                    extractionManager.removeExtractionById(oldExtraction.id);
                }
            }
        });
    });
}

// ============================================
// Step Navigation
// ============================================
function initializeStepNavigation() {
    const prevBtn = document.getElementById('prev-btn');
    const nextBtn = document.getElementById('next-btn');
    const submitBtn = document.getElementById('submit-btn');
    
    nextBtn.addEventListener('click', () => navigateStep(1));
    prevBtn.addEventListener('click', () => navigateStep(-1));

    submitBtn.addEventListener('click', (e) => {
        e.preventDefault();
        if (validateForm()) {
            showStatus('Extraction completed. Generating exports...', 'success');
            exportJSON();
            // exportAuditHTML(); // Uncomment when implemented
        }
    });

    updateNavigation();
}

function navigateStep(direction) {
    const newStep = AppState.currentStep + direction;
    if (newStep >= 0 && newStep < AppState.totalSteps) {
        AppState.currentStep = newStep;
        updateNavigation();
    }
}

function navigateToStepContainingField(field) {
    const stepElement = field.closest('.step');
    if (stepElement) {
        const steps = Array.from(document.querySelectorAll('.step'));
        const stepIndex = steps.indexOf(stepElement);
        if (stepIndex !== -1 && stepIndex !== AppState.currentStep) {
            AppState.currentStep = stepIndex;
            updateNavigation();
        }
    }
}

function updateNavigation() {
    const steps = document.querySelectorAll('.step');
    const prevBtn = document.getElementById('prev-btn');
    const nextBtn = document.getElementById('next-btn');
    const submitBtn = document.getElementById('submit-btn');
    const indicator = document.getElementById('step-indicator');

    steps.forEach((step, index) => {
        step.classList.toggle('active', index === AppState.currentStep);
    });

    prevBtn.disabled = AppState.currentStep === 0;
    const isLastStep = AppState.currentStep === AppState.totalSteps - 1;
    nextBtn.style.display = isLastStep ? 'none' : 'inline-block';
    submitBtn.style.display = isLastStep ? 'inline-block' : 'none';
    indicator.textContent = `Step ${AppState.currentStep + 1} of ${AppState.totalSteps}`;
    
    // Update progress bar based on steps
    const progress = ((AppState.currentStep + 1) / AppState.totalSteps) * 100;
    document.getElementById('progress-bar').style.width = `${progress}%`;
}

function validateForm() {
    const form = document.getElementById('extraction-form');
    if (!form.checkValidity()) {
        showStatus('Please fill out all required fields.', 'error');
        form.reportValidity();
        // Navigate to the first step with an error
        const firstInvalid = form.querySelector(':invalid');
        if (firstInvalid) {
            navigateToStepContainingField(firstInvalid);
            firstInvalid.focus();
        }
        return false;
    }
    return true;
}

// ============================================
// PDF Controls
// ============================================
function changeZoom(scale) {
    AppState.scale = parseFloat(scale);
    renderPage(AppState.currentPage);
}

function fitToWidth() {
    const container = document.getElementById('pdf-container');
    const containerWidth = container.clientWidth - 40;
    
    if (AppState.pdfDoc) {
        AppState.pdfDoc.getPage(AppState.currentPage).then(page => {
            const viewport = page.getViewport({ scale: 1.0 });
            AppState.scale = containerWidth / viewport.width;
            renderPage(AppState.currentPage);
        });
    }
}

// ============================================
// Initialize Application
// ============================================
document.addEventListener('DOMContentLoaded', () => {
    initializeFormFields();
    initializeStepNavigation();
    
    // Setup file input
    document.getElementById('pdf-file').addEventListener('change', (e) => {
        if (e.target.files[0]) {
            loadPDF(e.target.files[0]);
        }
    });
    
    // Setup page navigation listeners
    document.getElementById('pdf-prev-page').addEventListener('click', () => renderPage(AppState.currentPage - 1));
    document.getElementById('pdf-next-page').addEventListener('click', () => renderPage(AppState.currentPage + 1));
    
    document.getElementById('page-num').addEventListener('change', (e) => {
        const pageNum = parseInt(e.target.value);
        renderPage(pageNum);
    });
    
    // Setup search
    document.getElementById('pdf-search-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            searchPDF();
        }
    });
    
    showStatus('System initialized. Load a PDF (Ctrl+O) to begin.', 'info');
});

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
    if ((e.ctrlKey || e.metaKey) && e.key === 'o') {
        e.preventDefault();
        document.getElementById('pdf-file').click();
    }
    
    if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
        e.preventDefault();
        undoLastExtraction();
    }
    
    if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
        e.preventDefault();
        document.getElementById('pdf-search-input').focus();
    }
    
    // Page navigation with arrow keys
    if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
        if (e.key === 'ArrowLeft') {
            renderPage(AppState.currentPage - 1);
        } else if (e.key === 'ArrowRight') {
            renderPage(AppState.currentPage + 1);
        }
    }
});
</script>

</body>
</html>
